<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core" #>
<#@ Assembly Name="System.Windows.Forms" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     GitVersion
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

<#
int startItem = 1;
int endItem = 10;
#>
namespace Lucile.Data
{
<#if(startItem == 1){#>
	public abstract class DynamicTuple
	{
		public virtual object GetValue(int index)
		{
			throw new IndexOutOfRangeException($"Invalid value index {index} for tuple.");
		}

		public virtual void SetValue(int index, object value)
		{
			throw new IndexOutOfRangeException($"Invalid value index {index} for tuple.");
		}

		public static Type GetTupleType(params Type[] types){
			switch(types.Length){
<#for(int i = startItem; i <= endItem; i++){#>
				case <#=i#>:
					return typeof(DynamicTuple<<#=new String(',',i - 1)#>>).MakeGenericType(types); 
<#}#>
			}

			throw new InvalidOperationException($"The minimum is 1 and the maximus are 400 Properties for dynamic tuples.");
		}

		public static DynamicTuple Get(params Type[] types){
			return (DynamicTuple)Activator.CreateInstance(GetTupleType(types)); 
		}
	}
<#}#>
<#
for(int i = startItem; i <= endItem; i++){
#>
	public class DynamicTuple<<#=string.Join(", ", Enumerable.Range(0,i).Select(p => $"T{p}"))#>> 
<#if(i > 1){#>
		: DynamicTuple<<#=string.Join(", ", Enumerable.Range(0,i - 1).Select(p => $"T{p}"))#>>
<#} else {#>
		: DynamicTuple
<#}#>
	{
		public T<#=i - 1#> Value<#=i - 1#> { get; set; }

		public override object GetValue(int index)
		{
			if(index == <#=i - 1#>){
				return Value<#=i - 1#>;
			}

			return base.GetValue(index);
		}

		public override void SetValue(int index, object value)
		{
			if(index == <#=i - 1#>){
				Value<#=i - 1#> = (T<#=i-1#>)value;
				return;
			}

			base.SetValue(index, value);
		}
	}
<#
}
#>
}