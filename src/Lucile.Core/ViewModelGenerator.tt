<#@ template hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.ComponentModel" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ include file="EF.Utility.CS.ttinclude" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<#
  //var fileManager = EntityFrameworkTemplateFileManager.Create(this);
	var classes = GetClasses().Distinct().ToArray();
  foreach(var t in classes){
	//fileManager.StartNewFile("Partial." + t.FullName.Substring(t.FullName.LastIndexOf(".") + 1).Replace("<","_").Replace(">","_") + ".cs");
#>
namespace <#= t.Namespace.FullName #> {
<#
	foreach(var item in GetUsingDirectives(t.ProjectItem.FileCodeModel.CodeElements)){
#>
	using <#=item.Namespace#>;
<#
	}
	
	string[] implementations = t.Bases.OfType<CodeElement>().Select(p => p.FullName)
								.Union(t.ImplementedInterfaces.OfType<CodeElement>().Select(p => p.FullName))
								.ToArray();
	
	bool renderPropertyChanged = Implements<INotifyPropertyChanged>(t);
	bool renderPropertyChanging = Implements<INotifyPropertyChanging>(t);

	Write(GetAccessorString(t.Access));
	#><#= t.IsAbstract ? " abstract": string.Empty#> partial class <#= t.FullName.Substring(t.FullName.LastIndexOf(".") + 1) #> <#= implementations.Length > 0 ? ":" : string.Empty#> <#= string.Join(", ",implementations)#>{
	<#foreach(var p in GetViewModelPropertiesFromClass(t)){#>
	
	partial void On<#=p.PropertyName#>Changing(<#=p.PropertyType #> oldValue, <#=p.PropertyType #> newValue, ref bool handled);
	partial void On<#=p.PropertyName#>Changed();
	private <#=p.PropertyType #> val<#=p.PropertyName#>;
	
	<#foreach(var a in p.Attributes){#>
	[<#=a#>]
	<#}#>
	<#=p.Accessor ?? "public"#> <#=p.PropertyType #> <#=p.PropertyName#>{
			<#=p.GetAccessor ?? string.Empty#> get
			{
				return val<#= p.PropertyName#>;
			}
			<#=p.SetAccessor ?? string.Empty#> set
			{
<#if(p.IsGeneric){#>
				if (!System.Collections.Generic.EqualityComparer<<#=p.PropertyType #>>.Default.Equals(val<#= p.PropertyName#>,value))
<#} else{#>
				if (val<#= p.PropertyName#> != value)
<#}#> 
				{
					bool handled = false;
					On<#= p.PropertyName#>Changing(val<#= p.PropertyName#>, value,ref handled);
<#if (renderPropertyChanging){#>
					handled = handled || RaisePropertyChanging("<#= p.PropertyName#>",val<#= p.PropertyName#>, value);
<#}#>
					if (!handled){
						val<#= p.PropertyName#> = value;
						On<#= p.PropertyName#>Changed();
<#if (renderPropertyChanged){#>
						RaisePropertyChanged("<#= p.PropertyName#>");
<#}#>
					}
				}
			}
		}
	<#}#>
}
}
<#
//fileManager.EndBlock();
}
//fileManager.Process();
#>
<#+
	private IEnumerable<CodeClass> GetClasses()
	{
		IServiceProvider hostServiceProvider = (IServiceProvider)this.Host;
		var dte = (DTE)hostServiceProvider.GetService(typeof(DTE));
		ProjectItem projectItem = dte.Solution.FindProjectItem(this.Host.TemplateFile);
		var project = projectItem.ContainingProject;

		foreach(ProjectItem item in GetProjectItems(project.ProjectItems).Distinct()){
			FileCodeModel codeModel = item.FileCodeModel;
			if (codeModel != null){
				foreach(var codeClass in FindViewModelClasses(codeModel.CodeElements)){
					yield return codeClass;
				}
			}
		}
		yield break;
	}
	
	private IEnumerable<ProjectItem> Enumerate(ProjectItems projectItems)
    {
        foreach (ProjectItem item in projectItems)
        {
            yield return item;
 
            if (item.SubProject != null)
            {
                foreach (ProjectItem childItem in Enumerate(item.SubProject.ProjectItems))
                    yield return childItem;
            }
            else
            {
                foreach (ProjectItem childItem in Enumerate(item.ProjectItems))
                    yield return childItem;
            }
        }
    }


	private IEnumerable<ProjectItem> GetProjectItems(ProjectItems projectItems){
		return Enumerate(projectItems);
		//foreach(ProjectItem item in projectItems){
		//	yield return item;
		//	foreach(ProjectItem test in item.ProjectItems){
		//		foreach(ProjectItem test2 in GetProjectItems(test.ProjectItems)){
		//			yield return test2;
		//		}
		//	}
		//}
	} 

	private IEnumerable<CodeClass> GetBaseClasses(CodeElements elements){
		foreach(CodeElement element in elements){
			if (element is CodeClass){
				yield return (CodeClass)element;
				foreach(var item in GetBaseClasses(((CodeClass)element).Bases)){
					yield return item;
				}
			}
		}
	}
	
	private IEnumerable<CodeImport> GetUsingDirectives(CodeElements elements){
		foreach(CodeElement element in elements){
			if (element.Kind == vsCMElement.vsCMElementImportStmt){
				yield return (CodeImport)element;
			} else {
				foreach(var item in GetUsingDirectives(element.Children)){
					yield return item;
				}
			}
		}
	}
	
	private IEnumerable<CodeClass> FindViewModelClasses(CodeElements elements)
	{
		foreach (CodeElement element in elements)
		{
			CodeClass codeClass = element as CodeClass;
			
			if (codeClass != null && codeClass.Attributes.OfType<CodeAttribute>().Count(p => p.Name == "ViewModelProperty") > 0){
				yield return codeClass;
			}
			if(codeClass != null && codeClass.Children.OfType<CodeClass>().Any(p => p.Attributes.OfType<CodeAttribute>().Count(x => x.Name == "PropertyDeclaration" || x.Name == "PropertyDeclarationAttribute") > 0)){
				yield return codeClass;
			}
			if (element.Children != null){
				foreach(var item in FindViewModelClasses(element.Children))
					yield return item;
			}
		}
	}
	
	private IEnumerable<ViewModelProperty> GetViewModelPropertiesFromClass(CodeClass codeClass){
		foreach(CodeAttribute att in codeClass.Attributes.OfType<CodeAttribute>().Where(p => p.Name == "ViewModelProperty")){
			var vmp = new ViewModelProperty();
			var values = att.Value.Split(',').Select(p => p.Trim()).ToArray();
			vmp.PropertyName = values[0].Substring(1,values[0].Length - 2);
			vmp.PropertyType = values[1].Substring(7,values[1].Length - 8);
			vmp.IsReadOnly = values.Select(p => p.Split('=')).Where(p => p[0].Trim() == "IsReadOnly").Select(p => Boolean.Parse(p[1])).Count() > 0;
		
			yield return vmp;
		}

		var declarationClass = codeClass.Children.OfType<CodeClass>().Where(p => p.Children.OfType<CodeAttribute>().Any(x => x.Name == "PropertyDeclaration" || x.Name == "PropertyDeclaration")).FirstOrDefault();
		if(declarationClass != null)
		{
			foreach(var item in declarationClass.Children.OfType<CodeProperty>()){
				var vmp = new ViewModelProperty();
				vmp.PropertyName = item.Name;
				vmp.PropertyType = item.Type.AsFullName;
				vmp.Accessor = GetAccessorString(item.Access);
				vmp.GetAccessor = item.Getter.Access != item.Access ? GetAccessorString(item.Getter.Access) : null;
				vmp.SetAccessor = item.Setter.Access != item.Access ? GetAccessorString(item.Setter.Access) : null;
				vmp.Attributes.AddRange(item.Attributes.OfType<CodeAttribute>().Select(p => string.Format("{0}({1})",p.FullName, p.Value)));
				vmp.IsGeneric = item.Type.TypeKind == vsCMTypeRef.vsCMTypeRefOther;

				yield return vmp;
			}
		}
	}

	private string GetAccessorString(vsCMAccess access){
		switch(access){
			case vsCMAccess.vsCMAccessAssemblyOrFamily:
			case vsCMAccess.vsCMAccessProjectOrProtected:
				return "internal protected";
			case vsCMAccess.vsCMAccessPrivate:
				return "private";
			case vsCMAccess.vsCMAccessProject:
				return "internal";
			case vsCMAccess.vsCMAccessProtected:
				return "protected";
			case vsCMAccess.vsCMAccessPublic:
				return "public";
			case vsCMAccess.vsCMAccessWithEvents:
			case vsCMAccess.vsCMAccessDefault:
			default:
				return string.Empty;
		}
	}
	
	private bool Implements<T>(CodeClass codeClass)
	{
		var fullName = typeof(T).FullName;
		if (codeClass.Bases.OfType<CodeElement>().Count(p => p.FullName == fullName) > 0)
			return true;
		else if (codeClass.ImplementedInterfaces.OfType<CodeElement>().Count(p => p.FullName == fullName) > 0){
			return true;
		} else {
			foreach(var item in codeClass.Bases.OfType<CodeClass>()){
				if (Implements<T>(item))
					return true;
			}
		}
		return false;
	}
	
	private class ViewModelProperty
	{
		public ViewModelProperty(){
			this.Attributes = new List<string>();
		}

		public string PropertyName { get; set; }	
		public string PropertyType { get; set; }
		public bool IsGeneric { get; set; }
		public string Accessor {get;set;}
		public string GetAccessor {get;set;}
		public string SetAccessor {get;set;}
		public List<string> Attributes{get;private set;}

		public bool IsReadOnly { 
			set {
				SetAccessor = value ? "private" : string.Empty;
			}
			get{
				return "private".Equals(this.SetAccessor,StringComparison.OrdinalIgnoreCase);
			}
		}
	}

#>